From 5bf97a2a296da01bab18e135546f4a63c888049c Mon Sep 17 00:00:00 2001
From: beaglejoe <BeagleJoe13@gmail.com>
Date: Fri, 12 Nov 2021 13:36:55 -0500
Subject: Reimplement X512s patch: Video: remove BDirectWindow, fix context
 management


diff --git a/src/main/haiku/SDL_BApp.h b/src/main/haiku/SDL_BApp.h
index 3d7e6f9..c236b01 100644
--- a/src/main/haiku/SDL_BApp.h
+++ b/src/main/haiku/SDL_BApp.h
@@ -198,6 +198,10 @@ public:
     }
 
 #if SDL_VIDEO_OPENGL
+    BGLView *GetCurrentContext() {
+        return _current_context;
+    }
+
     void SetCurrentContext(BGLView *newContext) {
         if(_current_context)
             _current_context->UnlockGL();
@@ -234,25 +238,22 @@ private:
         }
         win = GetSDLWindow(winID);
 
-		// Simple relative mode support for mouse.
-		if (SDL_GetMouse()->relative_mode) {
-			int winWidth, winHeight, winPosX, winPosY;
-			SDL_GetWindowSize(win, &winWidth, &winHeight);
-			SDL_GetWindowPosition(win, &winPosX, &winPosY);
-			int dx = x - (winWidth / 2);
-			int dy = y - (winHeight / 2);
-			SDL_SendMouseMotion(win, 0, SDL_GetMouse()->relative_mode, dx, dy);
-			set_mouse_position((winPosX + winWidth / 2), (winPosY + winHeight / 2));
-			if (!be_app->IsCursorHidden())
-				be_app->HideCursor();
-		} else {
-			SDL_SendMouseMotion(win, 0, 0, x, y);
-			if (SDL_ShowCursor(-1) && be_app->IsCursorHidden())
-				be_app->ShowCursor();
-		}
-
-        /* Tell the application that the mouse passed over, redraw needed */
-        HAIKU_UpdateWindowFramebuffer(NULL,win,NULL,-1);
+        // Simple relative mode support for mouse.
+        if (SDL_GetMouse()->relative_mode) {
+            int winWidth, winHeight, winPosX, winPosY;
+            SDL_GetWindowSize(win, &winWidth, &winHeight);
+            SDL_GetWindowPosition(win, &winPosX, &winPosY);
+            int dx = x - (winWidth / 2);
+            int dy = y - (winHeight / 2);
+            SDL_SendMouseMotion(win, 0, SDL_GetMouse()->relative_mode, dx, dy);
+            set_mouse_position((winPosX + winWidth / 2), (winPosY + winHeight / 2));
+            if (!be_app->IsCursorHidden())
+                be_app->HideCursor();
+        } else {
+            SDL_SendMouseMotion(win, 0, 0, x, y);
+            if (SDL_ShowCursor(-1) && be_app->IsCursorHidden())
+                be_app->ShowCursor();
+        }
     }
 
     void _HandleMouseButton(BMessage *msg) {
diff --git a/src/video/haiku/SDL_BWin.h b/src/video/haiku/SDL_BWin.h
index bfd2014..bca365b 100644
--- a/src/video/haiku/SDL_BWin.h
+++ b/src/video/haiku/SDL_BWin.h
@@ -39,7 +39,6 @@ extern "C" {
 #include <AppKit.h>
 #include <Cursor.h>
 #include <InterfaceKit.h>
-#include <game/DirectWindow.h>
 #if SDL_VIDEO_OPENGL
 #include <opengl/GLView.h>
 #endif
@@ -58,18 +57,45 @@ enum WinCommands {
     BWIN_SET_TITLE,
     BWIN_SET_BORDERED,
     BWIN_SET_RESIZABLE,
-    BWIN_FULLSCREEN
+    BWIN_FULLSCREEN,
+    BWIN_UPDATE_FRAMEBUFFER
 };
 
+// non-OpenGL framebuffer view
+class SDL_BView: public BView
+{
+public:
+    SDL_BView(BRect frame, const char* name, uint32 resizingMode)
+        : BView(frame, name, resizingMode, B_WILL_DRAW),
+        fBitmap(NULL)
+    {
+    }
+
+    void Draw(BRect dirty)
+    {
+        if (fBitmap != NULL)
+            DrawBitmap(fBitmap, B_ORIGIN);
+    }
+
+    void SetBitmap(BBitmap *bitmap)
+    {
+        fBitmap = bitmap;
+    }
+
+private:
+    BBitmap *fBitmap;
+};
 
-class SDL_BWin:public BDirectWindow
+class SDL_BWin: public BWindow
 {
   public:
     /* Constructor/Destructor */
     SDL_BWin(BRect bounds, window_look look, uint32 flags)
-        : BDirectWindow(bounds, "Untitled", look, B_NORMAL_WINDOW_FEEL, flags)
+        : BWindow(bounds, "Untitled", look, B_NORMAL_WINDOW_FEEL, flags)
     {
         _last_buttons = 0;
+        _cur_view = NULL;
+        _SDL_View = NULL;
 
 #if SDL_VIDEO_OPENGL
         _SDL_GLView = NULL;
@@ -79,59 +105,85 @@ class SDL_BWin:public BDirectWindow
         _inhibit_resize = false;
         _mouse_focused = false;
         _prev_frame = NULL;
+        _fullscreen = NULL;
 
         /* Handle framebuffer stuff */
-        _connected = _connection_disabled = false;
-        _buffer_created = _buffer_dirty = false;
-        _trash_window_buffer = false;
         _buffer_locker = new BLocker();
         _bitmap = NULL;
-        _clips = NULL;
-        _num_clips = 0;
-
-#ifdef DRAWTHREAD
-        _draw_thread_id = spawn_thread(HAIKU_DrawThread, "drawing_thread",
-                            B_NORMAL_PRIORITY, (void*) this);
-        resume_thread(_draw_thread_id);
-#endif
     }
 
     virtual ~ SDL_BWin()
     {
         Lock();
-        _connection_disabled = true;
-        int32 result;
+ 
+        if (_SDL_View != NULL && _SDL_View != _cur_view) {
+            delete _SDL_View; _SDL_View = NULL;
+        }
 
 #if SDL_VIDEO_OPENGL
         if (_SDL_GLView) {
-            _SDL_GLView->UnlockGL();
-            RemoveChild(_SDL_GLView);   /* Why was this outside the if
-                                            statement before? */
+            if (((SDL_BApp*)be_app)->GetCurrentContext() == _SDL_GLView)
+                ((SDL_BApp*)be_app)->SetCurrentContext(NULL);
+            if (_SDL_GLView == _cur_view) RemoveChild(_SDL_GLView);
+            _SDL_GLView = NULL;
+            // _SDL_GLView deleted by HAIKU_GL_DeleteContext
         }
 
 #endif
         Unlock();
-#if SDL_VIDEO_OPENGL
-        if (_SDL_GLView) {
-            delete _SDL_GLView;
-        }
-#endif
 
         delete _prev_frame;
 
         /* Clean up framebuffer stuff */
         _buffer_locker->Lock();
-#ifdef DRAWTHREAD
-        wait_for_thread(_draw_thread_id, &result);
-#endif
-        free(_clips);
         delete _buffer_locker;
     }
-
+
+        void SetCurView(BView *view)
+        {
+            if (_cur_view != view) {
+                if (_cur_view != NULL) RemoveChild(_cur_view);
+                _cur_view = view;
+                // printf("Current view is: %p (%s)\n", _cur_view, _cur_view == NULL? "": typeid(*_cur_view).name());
+                if (_cur_view != NULL) AddChild(_cur_view);
+            }
+        }
+
+        void UpdateCurView()
+        {
+            if (_SDL_GLView != NULL) {
+                SetCurView(_SDL_GLView);
+            } else if (_SDL_View != NULL) {
+                SetCurView(_SDL_View);
+            } else {
+                SetCurView(NULL);
+            }
+        }
+
+    SDL_BView *CreateView() {
+        Lock();
+        if (_SDL_View == NULL) {
+            _SDL_View = new SDL_BView(Bounds(), "SDL View", B_FOLLOW_ALL_SIDES);
+            UpdateCurView();
+        }
+        Unlock();
+        return _SDL_View;
+    }
+
+    void RemoveView() {
+        Lock();
+        if(_SDL_View != NULL) {
+            SDL_BView *oldView = _SDL_View;
+            _SDL_View = NULL;
+            UpdateCurView();
+            delete oldView;
+        }
+        Unlock();
+    }
 
     /* * * * * OpenGL functionality * * * * */
 #if SDL_VIDEO_OPENGL
-    virtual BGLView *CreateGLView(Uint32 gl_flags) {
+    BGLView *CreateGLView(Uint32 gl_flags) {
         Lock();
         if (_SDL_GLView == NULL) {
             _SDL_GLView = new BGLView(Bounds(), "SDL GLView",
@@ -139,95 +191,32 @@ class SDL_BWin:public BDirectWindow
                                      (B_WILL_DRAW | B_FRAME_EVENTS),
                                      gl_flags);
             _gl_type = gl_flags;
+            UpdateCurView();
         }
-        AddChild(_SDL_GLView);
-        _SDL_GLView->EnableDirectMode(false); /* Disable direct mode */
-        _SDL_GLView->LockGL();  /* "New" GLViews are created */
         Unlock();
-        return (_SDL_GLView);
+        return _SDL_GLView;
     }
 
-    virtual void RemoveGLView() {
+    void RemoveGLView() {
         Lock();
-        if(_SDL_GLView) {
-            _SDL_GLView->UnlockGL();
-            RemoveChild(_SDL_GLView);
+        if(_SDL_GLView != NULL) {
+            if (((SDL_BApp*)be_app)->GetCurrentContext() == _SDL_GLView)
+                ((SDL_BApp*)be_app)->SetCurrentContext(NULL);
+            _SDL_GLView = NULL;
+            UpdateCurView();
+            // _SDL_GLView deleted by HAIKU_GL_DeleteContext
         }
         Unlock();
     }
 
-    virtual void SwapBuffers(void) {
-        _SDL_GLView->UnlockGL();
-        _SDL_GLView->LockGL();
+    void SwapBuffers(void) {
         _SDL_GLView->SwapBuffers();
     }
 #endif
 
-    /* * * * * Framebuffering* * * * */
-    virtual void DirectConnected(direct_buffer_info *info) {
-        if(!_connected && _connection_disabled) {
-            return;
-        }
-
-        /* Determine if the pixel buffer is usable after this update */
-        _trash_window_buffer =      _trash_window_buffer
-                                || ((info->buffer_state & B_BUFFER_RESIZED)
-                                || (info->buffer_state & B_BUFFER_RESET)
-                                || (info->driver_state == B_MODE_CHANGED));
-        LockBuffer();
-
-        switch(info->buffer_state & B_DIRECT_MODE_MASK) {
-        case B_DIRECT_START:
-            _connected = true;
-
-        case B_DIRECT_MODIFY:
-            if (info->clip_list_count > _num_clips)
-            {
-                if(_clips) {
-                    free(_clips);
-                    _clips = NULL;
-                }
-            }
-
-            _num_clips = info->clip_list_count;
-            if (_clips == NULL)
-                _clips = (clipping_rect *)malloc(_num_clips*sizeof(clipping_rect));
-            if(_clips) {
-                memcpy(_clips, info->clip_list,
-                    _num_clips*sizeof(clipping_rect));
-
-                _bits = (uint8*) info->bits;
-                _row_bytes = info->bytes_per_row;
-                _bounds = info->window_bounds;
-                _bytes_per_px = info->bits_per_pixel / 8;
-                _buffer_dirty = true;
-            }
-            break;
-
-        case B_DIRECT_STOP:
-            _connected = false;
-            break;
-        }
-#if SDL_VIDEO_OPENGL
-        if(_SDL_GLView) {
-            _SDL_GLView->DirectConnected(info);
-        }
-#endif
-
-
-        /* Call the base object directconnected */
-        BDirectWindow::DirectConnected(info);
-
-        UnlockBuffer();
-
-    }
-
-
-
-
     /* * * * * Event sending * * * * */
     /* Hook functions */
-    virtual void FrameMoved(BPoint origin) {
+    void FrameMoved(BPoint origin) {
         /* Post a message to the BApp so that it can handle the window event */
         BMessage msg(BAPP_WINDOW_MOVED);
         msg.AddInt32("window-x", (int)origin.x);
@@ -235,10 +224,10 @@ class SDL_BWin:public BDirectWindow
         _PostWindowEvent(msg);
 
         /* Perform normal hook operations */
-        BDirectWindow::FrameMoved(origin);
+        BWindow::FrameMoved(origin);
     }
 
-    virtual void FrameResized(float width, float height) {
+    void FrameResized(float width, float height) {
         /* Post a message to the BApp so that it can handle the window event */
         BMessage msg(BAPP_WINDOW_RESIZED);
 
@@ -247,10 +236,10 @@ class SDL_BWin:public BDirectWindow
         _PostWindowEvent(msg);
 
         /* Perform normal hook operations */
-        BDirectWindow::FrameResized(width, height);
+        BWindow::FrameResized(width, height);
     }
 
-    virtual bool QuitRequested() {
+    bool QuitRequested() {
         BMessage msg(BAPP_WINDOW_CLOSE_REQUESTED);
         _PostWindowEvent(msg);
 
@@ -258,13 +247,13 @@ class SDL_BWin:public BDirectWindow
         return false;
     }
 
-    virtual void WindowActivated(bool active) {
+    void WindowActivated(bool active) {
         BMessage msg(BAPP_KEYBOARD_FOCUS);  /* Mouse focus sold separately */
         msg.AddBool("focusGained", active);
         _PostWindowEvent(msg);
     }
 
-    virtual void Zoom(BPoint origin,
+    void Zoom(BPoint origin,
                 float width,
                 float height) {
         BMessage msg(BAPP_MAXIMIZE);    /* Closest thing to maximization Haiku has */
@@ -275,13 +264,13 @@ class SDL_BWin:public BDirectWindow
             _prev_frame = new BRect(Frame());
 
         /* Perform normal hook operations */
-        BDirectWindow::Zoom(origin, width, height);
+        BWindow::Zoom(origin, width, height);
     }
 
     /* Member functions */
-    virtual void Show() {
+    void Show() {
         while(IsHidden()) {
-            BDirectWindow::Show();
+            BWindow::Show();
         }
         _shown = true;
 
@@ -289,25 +278,33 @@ class SDL_BWin:public BDirectWindow
         _PostWindowEvent(msg);
     }
 
-    virtual void Hide() {
-        BDirectWindow::Hide();
+    void Hide() {
+        BWindow::Hide();
         _shown = false;
 
         BMessage msg(BAPP_HIDE);
         _PostWindowEvent(msg);
     }
 
-    virtual void Minimize(bool minimize) {
-        BDirectWindow::Minimize(minimize);
+    void Minimize(bool minimize) {
+        BWindow::Minimize(minimize);
         int32 minState = (minimize ? BAPP_MINIMIZE : BAPP_RESTORE);
 
         BMessage msg(minState);
         _PostWindowEvent(msg);
     }
 
+    void ScreenChanged(BRect screenFrame, color_space depth)
+    {
+        if (_fullscreen) {
+            MoveTo(screenFrame.left, screenFrame.top);
+            ResizeTo(screenFrame.Width(), screenFrame.Height());
+        }
+    }
+
 
     /* BView message interruption */
-    virtual void DispatchMessage(BMessage * msg, BHandler * target)
+    void DispatchMessage(BMessage * msg, BHandler * target)
     {
         BPoint where;   /* Used by mouse moved */
         int32 buttons;  /* Used for mouse button events */
@@ -356,7 +353,7 @@ class SDL_BWin:public BDirectWindow
                 }
             }
             break;
-            
+
         case B_UNMAPPED_KEY_DOWN:      /* modifier keys are unmapped */
             if (msg->FindInt32("key", &key) == B_OK) {
                 _KeyEvent((SDL_Scancode)key, NULL, 0, SDL_PRESSED);
@@ -376,15 +373,15 @@ class SDL_BWin:public BDirectWindow
                - CTRL+Q to close window (and other shortcuts)
                - PrintScreen to make screenshot into /boot/home
                - etc.. */
-            /* BDirectWindow::DispatchMessage(msg, target); */
+            /* BWindow::DispatchMessage(msg, target); */
             break;
         }
 
-        BDirectWindow::DispatchMessage(msg, target);
+        BWindow::DispatchMessage(msg, target);
     }
 
     /* Handle command messages */
-    virtual void MessageReceived(BMessage* message) {
+    void MessageReceived(BMessage* message) {
         switch (message->what) {
             /* Handle commands from SDL */
             case BWIN_SET_TITLE:
@@ -396,12 +393,18 @@ class SDL_BWin:public BDirectWindow
             case BWIN_RESIZE_WINDOW:
                 _ResizeTo(message);
                 break;
-            case BWIN_SET_BORDERED:
-                _SetBordered(message);
-                break;
-            case BWIN_SET_RESIZABLE:
-                _SetResizable(message);
+            case BWIN_SET_BORDERED: {
+                bool bEnabled;
+                if (message->FindBool("window-border", &bEnabled) == B_OK)
+                    _SetBordered(bEnabled);
                 break;
+            }
+            case BWIN_SET_RESIZABLE: {
+                bool bEnabled;
+                if (message->FindBool("window-resizable", &bEnabled) == B_OK)
+                    _SetResizable(bEnabled);
+                 break;
+            }
             case BWIN_SHOW_WINDOW:
                 Show();
                 break;
@@ -417,12 +420,31 @@ class SDL_BWin:public BDirectWindow
             case BWIN_RESTORE_WINDOW:
                 _Restore();
                 break;
-            case BWIN_FULLSCREEN:
-                _SetFullScreen(message);
-                break;
+            case BWIN_FULLSCREEN: {
+                bool fullscreen;
+                if (message->FindBool("fullscreen", &fullscreen) == B_OK)
+                    _SetFullScreen(fullscreen);
+                 break;
+            }
+            case BWIN_UPDATE_FRAMEBUFFER: {
+                BMessage* pendingMessage;
+                while ((pendingMessage
+                                = MessageQueue()->FindMessage(BWIN_UPDATE_FRAMEBUFFER, 0))) {
+                        MessageQueue()->RemoveMessage(pendingMessage);
+                        delete pendingMessage;
+                }
+                if (_bitmap != NULL) {
+                    if (_SDL_View != NULL && _cur_view == _SDL_View)
+                        _SDL_View->Draw(Bounds());
+                    else if (_SDL_GLView != NULL && _cur_view == _SDL_GLView) {
+                        _SDL_GLView->CopyPixelsIn(_bitmap, B_ORIGIN);
+                    }
+                }
+                break;
+            }
             default:
                 /* Perform normal message handling */
-                BDirectWindow::MessageReceived(message);
+                BWindow::MessageReceived(message);
                 break;
         }
 
@@ -433,19 +455,9 @@ class SDL_BWin:public BDirectWindow
     /* Accessor methods */
     bool IsShown() { return _shown; }
     int32 GetID() { return _id; }
-    uint32 GetRowBytes() { return _row_bytes; }
-    int32 GetFbX() { return _bounds.left; }
-    int32 GetFbY() { return _bounds.top; }
-    bool ConnectionEnabled() { return !_connection_disabled; }
-    bool Connected() { return _connected; }
-    clipping_rect *GetClips() { return _clips; }
-    int32 GetNumClips() { return _num_clips; }
-    uint8* GetBufferPx() { return _bits; }
-    int32 GetBytesPerPx() { return _bytes_per_px; }
-    bool CanTrashWindowBuffer() { return _trash_window_buffer; }
-    bool BufferExists() { return _buffer_created; }
-    bool BufferIsDirty() { return _buffer_dirty; }
     BBitmap *GetBitmap() { return _bitmap; }
+    BView *GetCurView() { return _cur_view; }
+    SDL_BView *GetView() { return _SDL_View; }
 #if SDL_VIDEO_OPENGL
     BGLView *GetGLView() { return _SDL_GLView; }
     Uint32 GetGLType() { return _gl_type; }
@@ -453,12 +465,9 @@ class SDL_BWin:public BDirectWindow
 
     /* Setter methods */
     void SetID(int32 id) { _id = id; }
-    void SetBufferExists(bool bufferExists) { _buffer_created = bufferExists; }
     void LockBuffer() { _buffer_locker->Lock(); }
     void UnlockBuffer() { _buffer_locker->Unlock(); }
-    void SetBufferDirty(bool bufferDirty) { _buffer_dirty = bufferDirty; }
-    void SetTrashBuffer(bool trash) { _trash_window_buffer = trash;     }
-    void SetBitmap(BBitmap *bitmap) { _bitmap = bitmap; }
+    void SetBitmap(BBitmap *bitmap) { _bitmap = bitmap; if (_SDL_View != NULL) _SDL_View->SetBitmap(bitmap); }
 
 
 private:
@@ -564,7 +573,10 @@ private:
         ) {
             return;
         }
-        MoveTo(x, y);
+        if (_fullscreen)
+            _non_fullscreen_frame.OffsetTo(x, y);
+        else
+            MoveTo(x, y);
     }
 
     void _ResizeTo(BMessage *msg) {
@@ -575,26 +587,29 @@ private:
         ) {
             return;
         }
-        ResizeTo(w, h);
+        if (_fullscreen) {
+            _non_fullscreen_frame.right = _non_fullscreen_frame.left + w;
+            _non_fullscreen_frame.bottom = _non_fullscreen_frame.top + h;
+        } else
+            ResizeTo(w, h);
     }
 
-    void _SetBordered(BMessage *msg) {
-        bool bEnabled;
-        if(msg->FindBool("window-border", &bEnabled) != B_OK) {
-            return;
-        }
-        SetLook(bEnabled ? B_TITLED_WINDOW_LOOK : B_NO_BORDER_WINDOW_LOOK);
+    void _SetBordered(bool bEnabled) {
+        if (_fullscreen)
+            _bordered = bEnabled;
+        else
+            SetLook(bEnabled ? B_TITLED_WINDOW_LOOK : B_NO_BORDER_WINDOW_LOOK);
     }
 
-    void _SetResizable(BMessage *msg) {
-        bool bEnabled;
-        if(msg->FindBool("window-resizable", &bEnabled) != B_OK) {
-            return;
-        }
-        if (bEnabled) {
-            SetFlags(Flags() & ~(B_NOT_RESIZABLE | B_NOT_ZOOMABLE));
-        } else {
-            SetFlags(Flags() | (B_NOT_RESIZABLE | B_NOT_ZOOMABLE));
+    void _SetResizable(bool bEnabled) {
+        if (_fullscreen)
+            _resizable = bEnabled;
+        else {
+            if (bEnabled) {
+                SetFlags(Flags() & ~(B_NOT_RESIZABLE | B_NOT_ZOOMABLE));
+            } else {
+                SetFlags(Flags() | (B_NOT_RESIZABLE | B_NOT_ZOOMABLE));
+            }
         }
     }
 
@@ -603,23 +618,42 @@ private:
             Minimize(false);
         } else if(IsHidden()) {
             Show();
+        } else if (_fullscreen) {
+
         } else if(_prev_frame != NULL) {    /* Zoomed */
             MoveTo(_prev_frame->left, _prev_frame->top);
             ResizeTo(_prev_frame->Width(), _prev_frame->Height());
         }
     }
 
-    void _SetFullScreen(BMessage *msg) {
-        bool fullscreen;
-        if(
-            msg->FindBool("fullscreen", &fullscreen) != B_OK
-        ) {
-            return;
+    void _SetFullScreen(bool fullscreen) {
+        if (fullscreen != _fullscreen) {
+            if (fullscreen) {
+                BScreen screen(this);
+                BRect screenFrame = screen.Frame();
+                printf("screen frame: "); screenFrame.PrintToStream(); printf("\n");
+                _bordered = Look() != B_NO_BORDER_WINDOW_LOOK;
+                _resizable = !(Flags() & B_NOT_RESIZABLE);
+                _non_fullscreen_frame = Frame();
+                _SetBordered(false);
+                _SetResizable(false);
+                MoveTo(screenFrame.left, screenFrame.top);
+                ResizeTo(screenFrame.Width(), screenFrame.Height());
+                _fullscreen = fullscreen;
+            } else {
+                _fullscreen = fullscreen;
+                MoveTo(_non_fullscreen_frame.left, _non_fullscreen_frame.top);
+                ResizeTo(_non_fullscreen_frame.Width(), _non_fullscreen_frame.Height());
+                _SetBordered(_bordered);
+                _SetResizable(_resizable);
+            }
         }
-        SetFullScreen(fullscreen);
     }
 
     /* Members */
+
+    BView* _cur_view;
+    SDL_BView* _SDL_View;
 #if SDL_VIDEO_OPENGL
     BGLView * _SDL_GLView;
     Uint32 _gl_type;
@@ -632,23 +666,15 @@ private:
     bool  _inhibit_resize;
 
     BRect *_prev_frame; /* Previous position and size of the window */
+    bool _fullscreen;
+    // valid only if fullscreen
+    BRect _non_fullscreen_frame;
+    bool _bordered;
+    bool _resizable;
 
     /* Framebuffer members */
-    bool            _connected,
-                    _connection_disabled,
-                    _buffer_created,
-                    _buffer_dirty,
-                    _trash_window_buffer;
-    uint8          *_bits;
-    uint32          _row_bytes;
-    clipping_rect   _bounds;
-    BLocker        *_buffer_locker;
-    clipping_rect  *_clips;
-    uint32          _num_clips;
-    int32           _bytes_per_px;
-    thread_id       _draw_thread_id;
-
-    BBitmap        *_bitmap;
+    BLocker *_buffer_locker;
+    BBitmap *_bitmap;
 };
 
 
diff --git a/src/video/haiku/SDL_bframebuffer.cc b/src/video/haiku/SDL_bframebuffer.cc
index 785402b..8c253ca 100644
--- a/src/video/haiku/SDL_bframebuffer.cc
+++ b/src/video/haiku/SDL_bframebuffer.cc
@@ -35,9 +35,6 @@
 extern "C" {
 #endif
 
-#ifndef DRAWTHREAD
-static int32 HAIKU_UpdateOnce(SDL_Window *window);
-#endif
 
 static SDL_INLINE SDL_BWin *_ToBeWin(SDL_Window *window) {
     return ((SDL_BWin*)(window->driverdata));
@@ -56,11 +53,12 @@ int HAIKU_CreateWindowFramebuffer(_THIS, SDL_Window * window,
         return -1;
     }
 
-    while(!bwin->Connected()) { snooze(100); }
-    
+
     /* Make sure we have exclusive access to frame buffer data */
     bwin->LockBuffer();
 
+    bwin->CreateView();
+
     /* format */
     display_mode bmode;
     bscreen.GetMode(&bmode);
@@ -76,7 +74,7 @@ int HAIKU_CreateWindowFramebuffer(_THIS, SDL_Window * window,
     bitmap = new BBitmap(bwin->Bounds(), (color_space)bmode.space,
             false,    /* Views not accepted */
             true);    /* Contiguous memory required */
-            
+
     if(bitmap->InitCheck() != B_OK) {
         delete bitmap;
         return SDL_SetError("Could not initialize back buffer!");
@@ -84,15 +82,13 @@ int HAIKU_CreateWindowFramebuffer(_THIS, SDL_Window * window,
 
 
     bwin->SetBitmap(bitmap);
-    
+
     /* Set the pixel pointer */
     *pixels = bitmap->Bits();
 
     /* pitch = width of window, in bytes */
     *pitch = bitmap->BytesPerRow();
 
-    bwin->SetBufferExists(true);
-    bwin->SetTrashBuffer(false);
     bwin->UnlockBuffer();
     return 0;
 }
@@ -106,149 +102,28 @@ int HAIKU_UpdateWindowFramebuffer(_THIS, SDL_Window * window,
 
     SDL_BWin *bwin = _ToBeWin(window);
 
-#ifdef DRAWTHREAD    
-    bwin->LockBuffer();
-    bwin->SetBufferDirty(true);
-    bwin->UnlockBuffer();
-#else
-    bwin->SetBufferDirty(true);
-    HAIKU_UpdateOnce(window);
-#endif
+    bwin->PostMessage(BWIN_UPDATE_FRAMEBUFFER);
 
     return 0;
 }
 
-int32 HAIKU_DrawThread(void *data) {
-    SDL_BWin *bwin = (SDL_BWin*)data;
-    
-    BScreen bscreen;
-    if(!bscreen.IsValid()) {
-        return -1;
-    }
 
-    while(bwin->ConnectionEnabled()) {
-        if( bwin->Connected() && bwin->BufferExists() && bwin->BufferIsDirty() ) {
-            bwin->LockBuffer();
-            BBitmap *bitmap = NULL;
-            bitmap = bwin->GetBitmap();
-            int32 windowPitch = bitmap->BytesPerRow();
-            int32 bufferPitch = bwin->GetRowBytes();
-            uint8 *windowpx;
-            uint8 *bufferpx;
-
-            int32 BPP = bwin->GetBytesPerPx();
-            int32 windowSub = bwin->GetFbX() * BPP +
-                          bwin->GetFbY() * windowPitch;
-            clipping_rect *clips = bwin->GetClips();
-            int32 numClips = bwin->GetNumClips();
-            int i, y;
-
-            /* Blit each clipping rectangle */
-            bscreen.WaitForRetrace();
-            for(i = 0; i < numClips; ++i) {
-                /* Get addresses of the start of each clipping rectangle */
-                int32 width = clips[i].right - clips[i].left + 1;
-                int32 height = clips[i].bottom - clips[i].top + 1;
-                bufferpx = bwin->GetBufferPx() + 
-                    clips[i].top * bufferPitch + clips[i].left * BPP;
-                windowpx = (uint8*)bitmap->Bits() + 
-                    clips[i].top * windowPitch + clips[i].left * BPP -
-                    windowSub;
-
-                /* Copy each row of pixels from the window buffer into the frame
-                   buffer */
-                for(y = 0; y < height; ++y)
-                {
-
-                    if(bwin->CanTrashWindowBuffer()) {
-                        goto escape;    /* Break out before the buffer is killed */
-                    }
-
-                    memcpy(bufferpx, windowpx, width * BPP);
-                    bufferpx += bufferPitch;
-                    windowpx += windowPitch;
-                }
-            }
-
-            bwin->SetBufferDirty(false);
-escape:
-            bwin->UnlockBuffer();
-        } else {
-            snooze(16000);
-        }
-    }
-    
-    return B_OK;
-}
 
 void HAIKU_DestroyWindowFramebuffer(_THIS, SDL_Window * window) {
     SDL_BWin *bwin = _ToBeWin(window);
-    
+
     bwin->LockBuffer();
-    
+
     /* Free and clear the window buffer */
     BBitmap *bitmap = bwin->GetBitmap();
     delete bitmap;
     bwin->SetBitmap(NULL);
-    bwin->SetBufferExists(false);
-    bwin->UnlockBuffer();
-}
 
+    bwin->RemoveView();
 
-/*
- * TODO:
- * This was written to test if certain errors were caused by threading issues.
- * The specific issues have since become rare enough that they may have been
- * solved, but I doubt it- they were pretty sporadic before now.
- */
-#ifndef DRAWTHREAD
-static int32 HAIKU_UpdateOnce(SDL_Window *window) {
-    SDL_BWin *bwin = _ToBeWin(window);
-    BScreen bscreen;
-    if(!bscreen.IsValid()) {
-        return -1;
-    }
 
-    if(bwin->ConnectionEnabled() && bwin->Connected()) {
-        bwin->LockBuffer();
-        int32 windowPitch = window->surface->pitch;
-        int32 bufferPitch = bwin->GetRowBytes();
-        uint8 *windowpx;
-        uint8 *bufferpx;
-
-        int32 BPP = bwin->GetBytesPerPx();
-        uint8 *windowBaseAddress = (uint8*)window->surface->pixels;
-        int32 windowSub = bwin->GetFbX() * BPP +
-                          bwin->GetFbY() * windowPitch;
-        clipping_rect *clips = bwin->GetClips();
-        int32 numClips = bwin->GetNumClips();
-        int i, y;
-
-        /* Blit each clipping rectangle */
-        bscreen.WaitForRetrace();
-        for(i = 0; i < numClips; ++i) {
-            /* Get addresses of the start of each clipping rectangle */
-            int32 width = clips[i].right - clips[i].left + 1;
-            int32 height = clips[i].bottom - clips[i].top + 1;
-            bufferpx = bwin->GetBufferPx() + 
-                clips[i].top * bufferPitch + clips[i].left * BPP;
-            windowpx = windowBaseAddress + 
-                clips[i].top * windowPitch + clips[i].left * BPP - windowSub;
-
-            /* Copy each row of pixels from the window buffer into the frame
-               buffer */
-            for(y = 0; y < height; ++y)
-            {
-                memcpy(bufferpx, windowpx, width * BPP);
-                bufferpx += bufferPitch;
-                windowpx += windowPitch;
-            }
-        }
-        bwin->UnlockBuffer();
-    }
-    return 0;
+    bwin->UnlockBuffer();
 }
-#endif
 
 #ifdef __cplusplus
 }
diff --git a/src/video/haiku/SDL_bopengl.cc b/src/video/haiku/SDL_bopengl.cc
index 80fa20b..0c1cc99 100644
--- a/src/video/haiku/SDL_bopengl.cc
+++ b/src/video/haiku/SDL_bopengl.cc
@@ -30,6 +30,11 @@
 #include "SDL_BWin.h"
 #include "../../main/haiku/SDL_BApp.h"
 
+// TODO: remove when mesa package will be updated
+#ifndef BGL_SHARE_CONTEXT
+#define BGL_SHARE_CONTEXT 1024
+#endif
+
 #ifdef __cplusplus
 extern "C" {
 #endif
@@ -84,16 +89,21 @@ void *HAIKU_GL_GetProcAddress(_THIS, const char *proc)
 }
 
 
-
-
 int HAIKU_GL_SwapWindow(_THIS, SDL_Window * window) {
     _ToBeWin(window)->SwapBuffers();
     return 0;
 }
 
 int HAIKU_GL_MakeCurrent(_THIS, SDL_Window * window, SDL_GLContext context) {
-    SDL_BWin* win = (SDL_BWin*)context;
-    _GetBeApp()->SetCurrentContext(win ? win->GetGLView() : NULL);
+    BGLView* glView = (BGLView*)context;
+    // printf("HAIKU_GL_MakeCurrent(%llx), win = %llx, thread = %d\n", (uint64)context, (uint64)window, find_thread(NULL));
+    if (glView != NULL) {
+        if ((glView->Window() == NULL) || (window == NULL) || (_ToBeWin(window)->GetGLView() != glView)) {
+            SDL_SetError("MakeCurrent failed");
+            return -1;
+        }
+    }
+    _GetBeApp()->SetCurrentContext(glView);
     return 0;
 }
 
@@ -102,6 +112,11 @@ SDL_GLContext HAIKU_GL_CreateContext(_THIS, SDL_Window * window) {
     /* FIXME: Not sure what flags should be included here; may want to have
        most of them */
     SDL_BWin *bwin = _ToBeWin(window);
+    // printf("HAIKU_GL_CreateContext, win = %llx, thread = %d\n", (uint64)window, find_thread(NULL));
+    if (bwin->GetGLView() != NULL) {
+        SDL_SetError("Context already creaded");
+        return NULL;
+    }
     Uint32 gl_flags = BGL_RGB;
     if (_this->gl_config.alpha_size) {
         gl_flags |= BGL_ALPHA;
@@ -123,13 +138,23 @@ SDL_GLContext HAIKU_GL_CreateContext(_THIS, SDL_Window * window) {
             _this->gl_config.accum_alpha_size) {
         gl_flags |= BGL_ACCUM;
     }
+    if (_this->gl_config.share_with_current_context) {
+        gl_flags |= BGL_SHARE_CONTEXT;
+    }
     bwin->CreateGLView(gl_flags);
-    return (SDL_GLContext)(bwin);
+    _GetBeApp()->SetCurrentContext(bwin->GetGLView());
+    return (SDL_GLContext)(bwin->GetGLView());
 }
 
 void HAIKU_GL_DeleteContext(_THIS, SDL_GLContext context) {
-    /* Currently, automatically unlocks the view */
-    ((SDL_BWin*)context)->RemoveGLView();
+    // printf("HAIKU_GL_DeleteContext(%llx), thread = %d\n", (uint64)context, find_thread(NULL));
+    BGLView* glView = (BGLView*)context;
+    SDL_BWin *bwin = (SDL_BWin*)glView->Window();
+    if (bwin == NULL) {
+        delete glView;
+    } else {
+        bwin->RemoveGLView();
+    }
 }
 
 
-- 
2.30.2

